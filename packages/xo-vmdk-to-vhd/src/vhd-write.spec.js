'use strict'

import expect from 'must'
import {createWriteStream} from 'fs'
import {describe, it} from 'mocha'
import {exec} from 'child-process-promise'
import {readFile} from 'fs-promise'

import {
  computeChecksum,
  computeGeometryForSize,
  createDynamicDiskHeader,
  createFooter,
  ReadableRawVHDStream,
  VHDFile,
} from './vhd-write'

describe('VHD writing', () => {
  it('computeChecksum() is correct against some reference values', () => {
    // those values were taken from a file generated by qemu
    const testValue1 = '636F6E6563746978000000020001000000000000000002001F34DB9F71656D75000500035769326B0000000000019800000000000001980000030411000000030000000033B3A5E17F94433498376740246E5660'
    const expectedChecksum1 = 0xFFFFEFB2
    const testValue2 = '6378737061727365FFFFFFFFFFFFFFFF0000000000000600000100000000000100200000'
    const expectedChecksum2 = 0xFFFFF476
    expect(computeChecksum(Buffer.from(testValue1, 'hex'))).to.equal(expectedChecksum1)
    expect(computeChecksum(Buffer.from(testValue2, 'hex'))).to.equal(expectedChecksum2)
  })

  it('createFooter() does not crash', () => {
    createFooter(104448, Math.floor(Date.now() / 1000), {cylinders: 3, heads: 4, sectorsPerTrack: 17})
  })

  it('createDynamicDiskHeader() does not crash', () => {
    createDynamicDiskHeader(1, 0x00200000)
  })

  it('ReadableRawVHDStream does not crash', () => {
    const data = [{
      lbaBytes: 100,
      grain: Buffer.from('azerzaerazeraze', 'ascii'),
    }, {
      lbaBytes: 700,
      grain: Buffer.from('gdfslkdfguer', 'ascii'),
    }]
    let index = 0
    const mockParser = {
      next: () => {
        if (index < data.length) {
          const result = data[index]
          index++
          return result
        } else {
          return null
        }
      },
    }
    const stream = new ReadableRawVHDStream(100000, mockParser)
    const pipe = stream.pipe(createWriteStream('outputStream'))
    return new Promise((resolve, reject) => {
      pipe.on('finish', resolve)
      pipe.on('error', reject)
    })
  })

  it('ReadableRawVHDStream detects when blocks are out of order', () => {
    const data = [{
      lbaBytes: 700,
      grain: Buffer.from('azerzaerazeraze', 'ascii'),
    }, {
      lbaBytes: 100,
      grain: Buffer.from('gdfslkdfguer', 'ascii'),
    }]
    let index = 0
    const mockParser = {
      next: () => {
        if (index < data.length) {
          const result = data[index]
          index++
          return result
        } else {
          return null
        }
      },
    }
    return expect(new Promise((resolve, reject) => {
      const stream = new ReadableRawVHDStream(100000, mockParser)
      stream.on('error', reject)
      const pipe = stream.pipe(createWriteStream('outputStream'))
      pipe.on('finish', resolve)
      pipe.on('error', reject)
    })).to.reject.to.equal('This VMDK file does not have its blocks in the correct order')
  })

  it('writing a known file with VHDFile is successful', async () => {
    const fileName = 'output.vhd'
    const rawFilename = 'output.raw'
    const randomFileName = 'random.raw'
    const geometry = computeGeometryForSize(1024 * 1024 * 8)
    const dataSize = geometry.actualSize
    await exec('base64 /dev/urandom | head -c ' + dataSize + ' > ' + randomFileName)
    const buffer = await readFile(randomFileName)
    const f = new VHDFile(buffer.length, 523557791)
    const splitPoint = Math.floor(Math.random() * buffer.length)
    f.writeBuffer(buffer.slice(splitPoint), splitPoint)
    f.writeBuffer(buffer.slice(0, splitPoint), 0)
    f.writeBuffer(buffer.slice(splitPoint), splitPoint)
    await f.writeFile(fileName)
    await exec('qemu-img convert -fvpc -Oraw ' + fileName + ' ' + rawFilename)
    const fileContent = await readFile(rawFilename)
    expect(fileContent.length).to.equal(dataSize)
    for (let i = 0; i < fileContent.length; i++) {
      expect(fileContent[i]).to.equal(buffer[i])
    }
  })
})
